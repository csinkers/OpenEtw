module internal OpenEtw.GenerateNodePlugin
open OpenEtw.Util

let buildWrapperCpp (provider : EtwProvider) (options : NodeOptions) =
    let getId typeName collection selector key =
        let pickFunction x =
            let entityId, entityName = selector x
            if (entityName = key) then Some entityId else None

        let result = collection |> List.tryPick pickFunction
        match result with
        | Some x -> x
        | None -> failwithf "Error: %s \"%s\" was not defined." typeName key

    let getIdForChannel = getId "Channel" provider.channels (fun c -> (c.id, c.name))
    let getIdForLevel   = getId "Level"   provider.levels   (fun l -> (l.id, l.name))
    let getIdForOpcode  = getId "Opcode"  provider.opcodes  (fun o -> (o.id, o.name))
    let getIdForTask    = getId "Task"    provider.tasks    (fun t -> (t.id, t.name))

    let getMaskForKeywords =
        function
        | [] -> 0UL
        | names ->
            let keywords = names |> List.map (fun n -> provider.keywords |> List.find (fun k -> k.name = n))
            List.fold (|||) 0UL (keywords |> List.map (fun k -> k.id))

    let populateArgument i p =
        match p.count with
        | EtwCount.Single ->
            match p.inType with
            | AnsiString NullTerminated -> $"""    Local<String> string{i} = args[{i}]->ToString();
    String::Utf8Value utf8_{i}(string{i});
    const char *param{i} = *utf8_{i};
    if (param{i} == nullptr) param{i} = "(null)";"""
            | EtwType.UInt32 -> $"    const unsigned int param{i} = static_cast<unsigned int>(args[{i}]->NumberValue());"
            | EtwType.Int32  -> $"    const int param{i} = static_cast<int>(args[{i}]->NumberValue());"
            | EtwType.Float  -> $"    const float param{i} = static_cast<float>(args[{i}]->NumberValue());"
            | EtwType.Double -> $"    const double param{i} = args[{i}]->NumberValue();"
            | EtwType.Guid              -> $"""    GUID param{i}; ParseGuid(*String::Utf8Value(args[{i}]->ToString()), param{i});"""
            | EtwType.ActivityId        -> $"""    GUID param{i}; ParseGuid(*String::Utf8Value(args[{i}]->ToString()), param{i});"""
            | EtwType.RelatedActivityId -> $"""    GUID param{i}; ParseGuid(*String::Utf8Value(args[{i}]->ToString()), param{i});"""
            | _ -> failwithf "Unsupported data type: %A" p

        | EtwCount.Fixed count        -> failwithf "Unsupported data type: %A" p
        | EtwCount.Counted countParam -> failwithf "Unsupported data type: %A" p

    let populateArgumentForCall i p =
        match p.inType, p.outType with
        | EtwType.Guid, _ 
        | EtwType.ActivityId, _ 
        | EtwType.RelatedActivityId, _ -> $"&param{i}"
        | _, EtwOutType.Map _ -> $"({provider.className}::{p.cppType})param{i}"
        | _ -> $"param{i}"

    let perEvent f = provider.events |> List.map f |> String.concat System.Environment.NewLine
    let perTask f = provider.tasks |> List.map f |> String.concat System.Environment.NewLine
    let lookupTask name = provider.tasks |> List.find (fun t -> t.name = name)
    let groupedContexts = // ((contextId, keywordMask, level), eventId list) list
        provider.events
        |> List.map (fun e -> ((e.keywords |> getMaskForKeywords, e.level |> getIdForLevel), e.id))
        |> List.groupBy fst
        |> List.mapi (fun i ((k, l), members) -> ((i,k,l), members |> List.map snd))

    let eventContextIdLookup = // map from eventId to contextId
        groupedContexts
        |> List.collect (fun ((i,k,l), eventIds) -> eventIds |> List.map (fun e -> (e, i)) )
        |> Map.ofList

    let distinctContexts = groupedContexts |> List.map fst // (contextId:int, keywordMask:uint64, level:int) list
    let distinctContextCount = List.length distinctContexts
    let requiredBitMasks = (distinctContextCount + 31) / 32 // 32 bits in a ULONG

    [
        (if options.usePrecompiledHeader then "#include \"stdafx.h\"" else "")
        $"""// -----------------------------------------------------
//  This file was generated by EtwGen.exe
// -----------------------------------------------------

#include <node.h>
#include <v8.h>
#include "{options.headerName}" """

        // Preamble //
        """
using namespace v8;

enum class GuidParseState
{
    Long,
    Short1,
    Short2,
    Chars
};

bool ParseGuid(const char *s, GUID &guid)
{
    if(!s) return false;

    guid.Data1 = 0;
    guid.Data2 = 0;
    guid.Data3 = 0;
    for (unsigned char& n : guid.Data4) n =  0;

    auto state = GuidParseState::Long;
    auto shift = 32;
    auto i = 0;

    const auto nibble = [](char x) {
        switch (x)
        {
        case '0': return 0x0;
        case '1': return 0x1;
        case '2': return 0x2;
        case '3': return 0x3;
        case '4': return 0x4;
        case '5': return 0x5;
        case '6': return 0x6;
        case '7': return 0x7;
        case '8': return 0x8;
        case '9': return 0x9;
        case 'A': return 0xA;
        case 'B': return 0xB;
        case 'C': return 0xC;
        case 'D': return 0xD;
        case 'E': return 0xE;
        case 'F': return 0xF;
        case 'a': return 0xA;
        case 'b': return 0xB;
        case 'c': return 0xC;
        case 'd': return 0xD;
        case 'e': return 0xE;
        case 'f': return 0xF;
        default: return -1;
        }
    };

    if (*s == '{') s++;

    while(*s) {
        if(*s == '-') {
            s++;
            continue;
        }

        switch (state) {
        case GuidParseState::Long: {
            shift -= 4;
            const int x = nibble(*s);
            if (x == -1) return false;
            guid.Data1 |= (x << shift);

            if (!shift) {
                state = GuidParseState::Short1;
                shift = 16;
            }
            break;
        }
        case GuidParseState::Short1: {
            shift -= 4;
            const int x = nibble(*s);
            if (x == -1) return false;
            guid.Data2 |= (x << shift);

            if (!shift) {
                state = GuidParseState::Short2;
                shift = 16;
            }
            break;
        }
        case GuidParseState::Short2: {
            shift -= 4;
            const int x = nibble(*s);
            if (x == -1) return false;
            guid.Data3 |= (x << shift);

            if (!shift) {
                state = GuidParseState::Chars;
                shift = 8;
            }
            break;
        }
        case GuidParseState::Chars: {
            shift -= 4;
            const int x = nibble(*s);
            if (x == -1) return false;
            guid.Data4[i] |= (x << shift);

            if (!shift) {
                shift = 8;
                i++;
            }

            if (i >= 8) return true;
            break;
        }
        }

        s++;
    }
    return false;
}
"""
        // Events //

        (perEvent (fun e ->
            sprintf """Handle<Value> %s(const Arguments &args)
{
    HandleScope scope;
%s
    %s::%s(%s);
    return scope.Close(Undefined());
}
"""
                    e.cppName
                    // e.parameters.Length // if(args.Length() < %d) return scope.Close(Undefined());
                    (e.parameters |> Seq.mapi populateArgument |> String.concat System.Environment.NewLine)
                    provider.className
                    e.cppName
                    (e.parameters |> Seq.mapi populateArgumentForCall  |> String.concat ", "))
        )

        (
            let exportEvent (e : EtwEvent)  =
                sprintf """    Export(exports, "%s", %s);"""
                    e.cppName e.cppName

        sprintf """void Export(Handle<Object> exports, const char* name, InvocationCallback function)
{
    exports->Set(String::NewSymbol(name), FunctionTemplate::New(function)->GetFunction());
}

Handle<Value> RegisterProvider(const Arguments &args)
{
    HandleScope scope;
    %s::Register();
    return scope.Close(Undefined());
}

void init(Handle<Object> exports)
{
%s
    Export(exports, "registerProvider", RegisterProvider);
}

NODE_MODULE(%s, init)
"""

            provider.className
            (perEvent exportEvent)
            provider.className)
    ] |> String.concat System.Environment.NewLine

(*
// Example main.js:
var etw = require(__dirname + '/build/Debug/<<PROVIDER_NAME>>');
var methods = require('./methods.js').methods;

methods.forEach(function (method) {
    exports[method] = etw[method];
});
*)

let buildMethodsJs (provider : EtwProvider) (options : NodeOptions) =
    let formatEvent (e:EtwEvent) = sprintf "    '%s'" e.cppName
    let formattedEvents = provider.events |> List.map formatEvent
    (sprintf """// -----------------------------------------------------

//  This file was generated by EtwGen.exe
// -----------------------------------------------------
exports.methods = [
%s
];

""" (("    'registerProvider'"::formattedEvents) |> String.concat (", " + System.Environment.NewLine)))

let buildBindingGyp provider =
    sprintf """{
  "targets": [
    {
      "target_name": "%s",
      "include_dirs": ["./"],
      "sources": [ "Provider.cpp", "Provider.Node.cpp" ]
    }
  ],
  "___comment": "This file was generated by EtwGen.exe"
}
"""    provider.className

let forProvider (provider : EtwProvider) (options : NodeOptions) =
    [
        (options.cppFilename, buildWrapperCpp provider options)
        ("methods.js", buildMethodsJs provider options)
        ("binding.gyp", buildBindingGyp provider)
    ]