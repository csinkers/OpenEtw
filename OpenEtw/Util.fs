module OpenEtw.Util
open System
open System.Security.Cryptography
open System.Text
open SerdesNet

[<System.Runtime.InteropServices.DllImport("kernel32.dll")>]
extern uint32 GetCurrentThreadId();

// Generates a GUID via hashing to be used w/ PerfView's EventSource support
// (e.g. Using *ProviderName instead of the full GUID or registering a provider)
let providerToGuid (name : string) =
    let namespaceBytes =
        [|
            0x48uy; 0x2Cuy; 0x2Duy; 0xB2uy; 0xC3uy; 0x90uy; 0x47uy; 0xC8uy;
            0x87uy; 0xF8uy; 0x1Auy; 0x15uy; 0xBFuy; 0xC1uy; 0x30uy; 0xFBuy
        |]

    use sha1 = SHA1.Create()
    let nameBytes = Encoding.BigEndianUnicode.GetBytes(name.ToUpperInvariant())
    sha1.TransformBlock(namespaceBytes, 0, namespaceBytes.Length, null, 0) |> ignore
    sha1.TransformFinalBlock(nameBytes, 0, nameBytes.Length) |> ignore
    let guidBytes = Array.init 16 (fun _ -> 0uy)
    Buffer.BlockCopy(sha1.Hash, 0, guidBytes, 0, 16)

    // Guid = Hash[0..15], with Hash[7] tweaked according to RFC 4122
    guidBytes.[7] <- ((guidBytes.[7] &&& 0x0Fuy) ||| 0x50uy)
    new Guid(guidBytes)

let (|??) a = // Like the C# ?? operator, but for option types.
    match a with
    | Some x -> (fun _ -> x)
    | None -> id

let (|Prefix|_|) (p:string) (s:string) =
    if (s.StartsWith p) then Some (s.Substring <| p.Length)
    else None

let buildReader (br : System.IO.BinaryReader) = new ReaderSerdes(br, br.BaseStream.Length, fun b -> System.Text.Encoding.UTF8.GetString(b))
let buildWriter (bw : System.IO.BinaryWriter) = new WriterSerdes(bw, fun s -> System.Text.Encoding.UTF8.GetBytes(s))

(*
module Seq =
  let groupAdjacent groupingFunction (input : seq<_>) = seq {
    use en = input.GetEnumerator()
    let running = ref true

    let rec group() = seq {
        let prev = en.Current
        if en.MoveNext() then
          if (groupingFunction (prev, en.Current)) then
              yield prev
              yield! group()
          else
              yield prev
        else
            yield prev
            running := false }

    if en.MoveNext() then
      while running.Value do
        yield group() }
*)

let etlEpoch = System.DateTime(1601, 1, 1)
let toEtlAbsoluteTicks (dt:System.DateTime) = dt.Ticks - etlEpoch.Ticks
let toEtlBootTicks (bootTime:System.DateTime) (dt:System.DateTime) = dt.Ticks - bootTime.Ticks
let fromEtlAbsoluteTicks ticks = System.DateTime(ticks + etlEpoch.Ticks)
let fromEtlBootTicks (bootTime:System.DateTime) ticks = System.DateTime(bootTime.Ticks + ticks)
let sizeWithPadding x = (8 * ((x + 7) / 8))
let paddingBytes x = (sizeWithPadding x) - x

let paddedString len (s:string) =
    let sBytes = System.Text.Encoding.Unicode.GetBytes(s)
    assert (sBytes.Length + 2 <= len)
    [
        sBytes
        (Array.create (len - sBytes.Length) 0uy)
    ] |> Array.concat

let buildEtwGenComment headerPath =
    let assembly = System.Reflection.Assembly.GetExecutingAssembly()
    let version = assembly.GetName().Version

    let headerBytes = System.IO.File.ReadAllBytes headerPath
    use md5 = MD5.Create()
    let hashBytes = md5.ComputeHash(headerBytes)
    // MD5.HashData(headerBytes)
    let hash = BitConverter.ToUInt32(hashBytes, 0)
    let hashString = sprintf "%08X" hash
    $"This file was generated by EtwGen {version} {hashString}"

let extractEtwGenComment headerPath =
    let regex = new System.Text.RegularExpressions.Regex(""".*(This file was generated by EtwGen .*)""")
    let headerLines = System.IO.File.ReadAllLines headerPath
    headerLines |> Seq.choose (fun line -> 
        let m = regex.Match(line)
        if (not m.Success) then None else
        Some (m.Groups.[1].Value.Trim())
    ) |> Seq.tryHead

